---
title: "Oktobar 1968."
date: 2023-10-15T07:07:07+00:00
categories:
  - Razvoj
tag:
  - razvoj
---

Dok Brajan Adam deÄaÄki peva o letu '69 kao najboljim danima ikada, u softverskoj industriji vlada samo-prozvana kriza. PoÅ¡to je godina iz naslova pesme samo referenca na seksualni Äin, dozvoljeno nam je da je promenimo, te upotrebimo istu pesmu za godinu pre, 1968. Najbolje godine, zar ne?

---

Nije nostalgija razlog zaÅ¡to se [vraÄ‡am na kraj Å¡ezdesetih proÅ¡log veka](https://oblac.rs/varljivo-leto-68/) (neÄ‡u viÅ¡e, obeÄ‡avam, a i koga briga). Fasciniran sam relevantnoÅ¡Ä‡u problema sa kojima su se suoÄavali tadaÅ¡nji programeri. SliÄnost sa stanjem danas je toliko velika, da sam poÅ¾eleo da tek na kraju teksta otkrijem izvornu godinu, sve vreme zavaravajuÄ‡i Äitaoca da je reÄ o nekakvim aktuelnim razmiÅ¡ljanjima. OÄigledno to ne radim: smisao ne treba dodatno pojaÄavati radi nedostatka neÄije paÅ¾nje.

Ukratko: 1968. i 1969. godine se okupila grupa vodeÄ‡ih "softverskih inÅ¾enjera" (ne, termin nije skovala Margaret Hamilton) kako bi reÅ¡ila tkzv. _softversku krizu_: razvoj softvera nije uspevao da prati zahteve industrije. Okupljanja nisu urodila plodom - bilo je naivno oÄekivati da Ä‡e nekakav okup jednom godiÅ¡nje napraviti bilo kakvu promenu. Ipak, nije sve baÄeno u vodu: ostao je trag razmiÅ¡ljanja o najvaÅ¾nijim problemima u softverskoj industriji tog vremena.

Red je i da postavimo u fokus i stepen razvitka informatiÄkih sistema tog doba. Programi su se izvrÅ¡avali na mejnfrejm raÄunarima (veliÄine ormana), hardver je bio vrlo bitna komponenta celog sistema, softveri su pisani da reÅ¡avaju probleme u industriji (koja je to mogla da priuÅ¡ti), na programima je radilo puno inÅ¾enjera, koristilo se puno maÅ¡inskog koda, ali je bilo i "viÅ¡ih" programskih jezika, projekti su trajali.

Da ne bude zabune: svi uÄesnici konferencije su i dalje (bili) samo ljudi; ne pravim idole od njih. Ima i potpuno promaÅ¡enih zapaÅ¾anja, ali neobiÄno malo. TakoÄ‘e se oseÄ‡a breme vremena u razmiÅ¡ljanjima; no to je potpuno u redu, jer su se okupili da reÅ¡e aktuelan problem, a ne da gledaju u staklenu kuglu.

Iza obe konferencije je ostao pisani izveÅ¡taj. Kopkalo me je da ga proÄitam i vidim koliko su razmiÅ¡ljanja tada bila drugaÄija. Sigurno smo napredovali za ovih pedesetak godina, zar ne? Ono Å¡to sam zatekao me je zaprepastilo (FOTO, VIDEO). Å alu na stranu, primetna je konvergencija zrelih ideja i zakljuÄaka. Gde su zavrÅ¡ile?

IzdvojiÄ‡u delove izveÅ¡taja prve konferencije koji su mi zapali za oko. Ima ih mnogo, mnogo viÅ¡e; dobar deo nisam preneo, neke sam verovatno propustio; a i ne bi imalo smisla da sve stavim ovde.

## IseÄci

> The dissemination of knowledge is of obvious value â€” the massive dissemination of error-loaded software is frightening.

Svi uÄesnici dele ovakav nekakav alarmantno-zabrinjavajuÄ‡i pogled na softverske greÅ¡ke. GreÅ¡ka je tada, jasno, bila skuplja nego danas; no opet, Äini mi se da je vladala zdrava doza namere da se doÄ‘e do sistema koji ispravno rade.

Danas je greÅ¡ka jeftina - ili, bar, jeftinija. Ispravnost sistema kao da je samo proporcionalna testovima. Umesto da nemamo greÅ¡ku, pristajemo na "greÅ¡ka nije pronaÄ‘ena". Takav stav implicira izvesnu degradaciju kvaliteta, zar ne?

> Today we tend to go on for years, with tremendous investments to find that the system, which was not well understood to start with, does not work as anticipated. We build systems like the Wright brothers built airplanes â€” build the whole thing, push it off the cliff, let it crash, and start over again.

Ima dana kada mislim da nismo daleko odmakli. Ostalim danima znam da nismo daleko odmakli.

MoÅ¾da je to samo stanje stvari, jedini pragmatiÄan naÄin razvoja? GrnÄar nebrojeno puta razbija napravljeno, usavrÅ¡avajuÄ‡i sebe i predmet koji stvara. Ako je veÄ‡ tako, zaÅ¡to kao programeri ne "razbijamo" viÅ¡e?

> Programming is still too much of an artistic endeavour. We need a more substantial basis to be taught and monitored in practice on the: (i) structure of programs and the flow of their execution; (ii) shaping of modules and an environment for their testing; (iii) simulation of run time conditions.

Programiranje [nije umetnost](https://oblac.rs/neostvareni-umetnici-razvoja/). Programiranje ne treba da bude umetnost. To Å¡to se neko oseÄ‡a nadahnuto tokom posla u kome sve "klikne" - nije umetnost. Pomisao da programiranje jeste bilo kakva umetnost je ujedno etiÄko unakaÅ¾avanje inÅ¾enjerskog poziva i pogrdno trivijalizovanje umetnosti. Zar nije naÅ¡a duÅ¾nost da slobodne veÅ¡tine razvoja pretvorimo u precizne, ponovljive, korake?

> There are two classes of system designers. The first, if given five problems will solve them one at a time. The second will come back and announce that these arenâ€™t the real problems, and will eventually propose a solution to the single problem which underlies the original five. This is the â€˜system typeâ€™ who is great during the initial stages of a design project. However, you had better get rid of him after the first six months if you want to get a working system.

Danas kao da viÅ¡e priÄamo o tome _Å¡ta_ znamo, nego _kako_ znamo. Na primer, naginjem ovoj drugoj grupi; zato se trudim da uoÄim kada je dosta, Å¡to mi teÅ¡ko polazi od ruke. Dodao bih da postoji potreba za sistemskim tipom razmiÅ¡ljanja na svakoj znaÄajnoj promeni: promena zahteva, poÄetak rada na novom modulu itd. Ove dve (tri, Äetiri?) grupe neprestano menjaju mesta, ali rade zajedno. MoÅ¾da ne bi bilo loÅ¡e poÄeti priÄati o tome _kako_ radimo, a ne koliko biblioteka znamo da koristimo?

> The design process is an iterative one. I will tell you one thing which can go wrong with it if you are not in the laboratory. In my terms design consists of:  
> 1. Flowchart until you think you understand the problem.  
> 2. Write code until you realize that you donâ€™t.  
> 3. Go back and re-do the flowchart.  
> 4. Write some more code and iterate to what you feel is the correct solution.

Ostavljam ovde uprkos svim teorijama zavere koje tvrde da se _ikada_ insistiralo da je waterfall jedini pravi naÄin razvoja softvera. Kako je doÅ¡lo dotle je druga priÄa, koju nastavljamo da proÅ¾ivljavamo i danas kroz druge aspekte softverskog razvoja.

> The most deadly thing in software is the concept, which almost universally seems to be followed, that you are going to specify what you are going to do, and then do it. And that is where most of our troubles come from. The projects that are called successful, have met their specifications. But those specifications were based upon the designersâ€™ ignorance before they started the job.

Kako znamo da specifikacija zaista odgovara potrebi? Jedini razumni odgovor koji mogu da ponudim: 1) dobijemo feedback Å¡to pre moguÄ‡e 2) prvo implementiramo vaÅ¾nije zahteve. Opet, i ovo je priliÄno nejasno. Kako znamo Å¡ta je vaÅ¾niji zahtev? Kako znamo da je feedback ispravan?

> What is needed is not classical mathematics, but mathematics. Systems should be built in levels and modules, which form a mathematical structure.

Slagali se ili ne, zemlja ostaje okrugla, a program zaista Äine matematiÄke strukture. Ako nam je matematiÄki aparat nadohvat ruke, zaÅ¡to se usteÅ¾emo? Ako neÅ¡to moÅ¾e da bude nedvosmisleno, zaÅ¡to nije?

> Three fundamental design concepts are essential to a maintainable system: modularity, specification, and generality. Modularity helps to isolate functional elements of the system. One module may be debugged, improved, or extended with minimal personnel interaction or system discontinuity. As important as modularity is specification. The key to production success of any modular construct is a rigid specification of the interfaces; the specification, as a side benefit, aids in the maintenance task by supplying the documentation necessary to train, understand, and provide maintenance. From this viewpoint, specification should encompass from the innermost primitive functions outward to the generalized functions such as a general file management system. Generality is essential to satisfy the requirement for extensibility.

SaÄuvajte ovo. â¤ï¸

> The approach suggested by Christopher Alexander in his book: Notes on the Synthesis of Form, is to make a tree structure of the decisions, so that you start by considering together those decisions that hang most closely together, and develop components that are sub-systems of your final design. Then you move up one step and combine them into larger units, always based on insight, of some kind, as to which design decisions are related to one another and which ones are not strongly related. I would consider this a very promising approach.

Nisam razmiÅ¡ljao o kombinovanju komponenti na ovakav naÄin. Nekako sam nauÄen da krenem od Å¡ire slike, pa da je usitnjavam. Tako negde i piÅ¡e, pa, gotovo svuda: problem se deli na korake i onda se oni zasebno reÅ¡avaju. Implicitno pretpostavljamo da se odluke preliju na pravi naÄin; jer imamo uvid u celu sliku od samog poÄetka. Implicitno pretpostavljamo i da na ispravan naÄin umemo da podelimo poÄetni problem.

Dugo veÄ‡ sumnjam da to nije ispravan naÄin dekompozicije. Å ira slika je uvek generalna, nejasna, neprecizna. Umesto toga, razvoj moÅ¾e krenuti od granÄica: spajati ih, uvezivati, menjati, pridruÅ¾ivati. Kako odmiÄemo, tako se pribliÅ¾avamo sve naprednijim funkcionalnostima koje se postavljaju na zdravu osnovu.

> Begin with skeletal coding: Rather than aiming at finished code, the first coding steps should be aimed at exploring interfaces, sizes of critical modules, complexity, and adequacy of the modules... Some critical items should be checked out, preferably on the hardware if it is available. If it is not, simulation is an alternative. The contributions of this step should be insight and experience, with the aim of exploring feasibility.

Deo koji se nadovezuje na prethodni. Hajde da odemo korak dalje - koliko puta ste odbacili inicijalni kod, usled boljeg razumevanja problema? Danas svuda priÄamo o efikasnosti, koju iz nepoznatog razloga ujedno izjednaÄavamo sa Å¡to manjim brojem izmena postojeÄ‡eg koga,Â zaÅ¡ta Äak postoji i metrika. Kada dozvoljavamo tektonske izmene projekta? Kao da jedino mali projekti i oni pravljeni od strane sramotno bogatih kompanija mogu sebi to da priuÅ¡te?

> The most frequently used definition â€” that a program is a sequence of instructions â€” forces one to ignore the role of data in the program. A better definition is that a program is a set of transformations and other relationships over sets of data and container structures. At least this definition guides the designer to break up a program design problem into the problems of establishing the various data and container structures required, and defining the operators over them. The definition requires that attention be paid to the properties of the data regardless of the containers (records, words, sectors, etc.), the properties of the containers themselves, and the properties of the data when combined with containers.

SaÄuvajte ovo. â¤ï¸

> Itâ€™s not sensible to make software better by making hardware better.

BaÅ¡ interesantna opaska. Ako hardver postane _znaÄajno_ jeftiniji, da li je opravdana degradacija kvaliteta softvera? Zavisi, naravno. Gde je granica? Da li je tamo gde je razumevanje koda bolje? Kako to da kod nije mogao da bude razumljiv i bez oslanjanja na poboljÅ¡anje hardvera?

> A standard joke in the industry is that a program typically remains 90% debugged for about 25% of the total implementation time.

ğŸ˜€

> The basic structure of the software, including modular divisions and interfaces, should be determined and documented before a coding begins. Specifications for modules and interfaces can be described in English, carefully phrased to avoid ambiguities.

Nedvosmileno svi uÄesnici ukazuju na to da je dokumentacija neophodni, neizostavni deo programiranja. Da li je tako i danas?

Uvid u neophodnost dokumentacije ilustruje primer koji se javlja kasnije u izveÅ¡taju. Na poÄetku projektu svaki Älan tima je dobio fasciklu sa tek po kojim papirom. Nakon nekog vremena, programerska dokumentacija u fascikli je "teÅ¾ila" Äak 4000 strana. Na odrÅ¾avanje dokumentacije je odlazilo 10%-20% vremena, ali je "totalno vredelo".

Kada se poslednji put radili sa dokumentacijom od bar 500 _odrÅ¾avanih_ strana? MoÅ¾da 100? Koliko procenata vremena utroÅ¡ite na pisanje razvojne dokumentacije (pre i tokom razvoja)?

> One type of error we have to contend with is inconsistency of specifications. I think it is probably impossible to specify a system completely free of ambiguities, certainly so if we use a natural language, such as English. If we had decent specification languages, which were non-ambiguous, perhaps this source of error could be avoided.

OdliÄno nadovezivanje na prethodnu misao. Govorni jezik je evoluirao samo dotle da prenosi tek dovoljno potrebnih informacija kako bi sluÅ¡alac tek dovoljno dobro razumeo o Äemu je reÄ. Govorni jezik, dakle, nije dovoljno precizan. Postojanje posebnog jezika za dokumentaciju bi imalo smisla; a to bi mogao da bude nekakav high-level jezik koji je ujedno i implementacija projekta, zar ne?

> The conclusion is that making the predocumentation at the proper moment, and using it, will improve the efficiency with which you construct your whole thing incredibly. One may wonder, if this is so obvious, why doesnâ€™t it happen? I would suggest that the reason why many programmers experience the making of predocumentation as an additional burden, instead of a tool, is that whatever predocumentation he produces can never be used mechanically. Only if we provide him with more profitable means, preferably mechanical, for using predocumentation, only then will the spiritual barrier be crossed.

SaÄuvajte ovo. â¤ï¸

> There is a principle, a kind of corollary to Parkinsonâ€™s Law, called the Peter Principle, named after a high school principal in Long Island. It goes like this: â€˜In the real world people are eventually promoted to their final level of incompetenceâ€™. That is, if a person is extremely competent at the particular level he happens to be working at, he is immediately promoted. This brings upon him additional responsibility. If he does well at that job he is eventually promoted again, and again, until he reaches the level where he no longer performs satisfactorily, and he is never promoted again. So people are left in a state of incompetence. This, in part, is the problem of any big project area.

ZvuÄi poznato?

> The system being produced will tend to have a structure which mirrors the structure of the group that is producing it, whether or not this was intended. One should take advantage of this fact, and then deliberately design the group structure so as to achieve the desired system structure.

Zanimljivo â€œhakovanjeâ€ Konvejevog zakona (koji nije, zapravo, zakon; veÄ‡ uoÄeni obrazac.) Da generalizujemo: ako postoji nekakav obrazac u timu/firmu, onda ga vredi namerno iskoristiti. Osim ako obrazac koÄi razvoj. Kako onda znamo koji obrazac ima smisla iskoristiti? ÄŒija je duÅ¾nost da se brine o tome?

> A design requirement for our Electronic Switching System was that it should not have more than two hours system downtime (both software and hardware) in 40 years.

ZapanjujuÄ‡i podatak. Zastanite za trenutak i odgovorite za sebe: Å¡ta bi sve promenili u svakodnevnom radu kada bi ovo bio zahtev? A potom odgovorite: da li vam je potreban ovakav zahtev da bi primenili zamiÅ¡ljene promene?

> A man can communicate with about five colleagues on a software project without too much difficulty. Likewise he can supervise about five people and know pretty well what they are doing. One would structure 120 people in three levels, in which no man is talking to more than about eight people, both across his level and up and down â€” which is well within our capabilities I think, since most of the communication will go across rather than down.

Prosta matematika malih timova: komunikaciju Äine _izvodljivom_. Sve van obima malog tima postaje Å¡um. U pitanju je ljudsko ograniÄenje, ne maÅ¡insko.

> So, in a system which will take a long time to complete, for example a year, nobody should be allowed to function permanently at one level, but should percolate. In a situation where code actually has to be produced, nobody should be allowed in the system who doesnâ€™t write some given number of lines of code per month.

Onog trenutka kada prestaneÅ¡ da programiraÅ¡ u produkciji, zastao si. Ne postoji drugaÄiji naÄin veÅ¾banja veÅ¡tina, Å¡ta god da je u pitanju. Kada stojiÅ¡, veÅ¡tina se vremenom prirodno rasipa. **Use it or loose it.**

Bilo da si postao menadÅ¾er ili YT influenser, tvoje veÅ¡tine razvoja stagniraju. U sluÄaju prvog, moÅ¾e biti opravdano novim karijernim putem. U sluÄaju drugog - da li je etiÄki korektno "prodavati" ono Äime se viÅ¡e ne baviÅ¡?

> My motto is 'do something small, useful, now.'

â¤ï¸

> The danger of writing a special piece of software to expedite production is that we have a project within a project. Often the inner project is more interesting and it is certainly more volatile in design. Thus it is never really complete, as its effectiveness is not known until it is used. This makes it extremely difficult to make deadlines and stick to them.

Nepopularan liÄni stav je da in-house projekti ne sluÅ¾e mnogo Äemu. Nekada davno sam mislio potpuno drugaÄije: video sam ih kao obaveznu aktivnost koju svaka firma dostojna svog imena _mora_ da sprovodi. Na kraju, to je zgodno mesto da uÄimo jedni od drugih, zar ne?

In-house projekti su morsko prase: niti su projekti, niti su proizvodi. Radi ko, kad i kako stigne. Jedva opravdaju svoje postojanje. Ubedite me u suprotno :)

> The initial release of a software system should work well (albeit with limited facilities) and must contain the basic system philosophies that ensure orderly growth.

Da li je ovo prva definicija MVPa?

> The economics of software development are such that the cost of maintenance frequently exceeds that of the original development.

Ovo vidim kao efekat toga da svaka preÄica danas koÅ¡ta u buduÄ‡nosti. To je OK, valjda, ukoliko su ti oÄekivanja poravnata. Ako ti je u redu da danas trÄiÅ¡ brÅ¾e (jer, novac), onda ti je isto tako u redu da Ä‡eÅ¡ uskoro hodati sporije.
 
> Testing is a very inefficient way of convincing oneself of the correctness of a program.

SaÄuvajte ovo. â¤ï¸

> Personally, after 18 years in the business I would like just once, just once, to be able to do the same thing again. Just once to try an evolutionary step instead of a confounded revolutionary one.

Stavio bih ovde smajlija, ali nisam siguran kojeg.

> We, in the Netherlands, have the title Mathematical Engineer. Software engineering seems to be the activity for the Mathematical Engineer par excellence. This seems to fit perfectly. On the one hand, we have all the aspects of an engineering activity, in that you are making something and want to see that it really works. On the other hand, our basic tools are mathematical in nature.

Stari latini kaÅ¾u: "Nomen est omen." Da li nam je naziv profesije ujedno i usud?

> Most of the designers of manufacturersâ€™ software are designing, I think, for their own benefit â€” they are literally playing games. They have no conception of validating their design before sending it out, or even evaluating the design in the light of potential use. The real problem is training the people to do the design. Most designers of software are damn well incompetent, one way or another.

LiÄi mi da se sve viÅ¡e bavimo preÄicama: kako zanemariti ispravno zarad veÄ‡ nekog proizvoljnog izgovora. Igramo se, zar ne? 