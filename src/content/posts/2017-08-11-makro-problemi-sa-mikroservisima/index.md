---
title: Makro problemi sa mikroservisima
date: 2017-08-11T09:53:22+00:00
slug: makro-problemi-sa-mikroservisima
description: >
  Arhitektura zasnovana na mikroservisima donosi svoje izazove. Ko bi rekao?
---

Arhitektura zasnovana na mikroservisima je, kako to [Fowler defini코e](https://martinfowler.com/articles/microservices.html):

> ...an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery.

Koncept mikroservisne arhitekture je sasvim u redu (i nije nov, povrh svega). Me캠utim, 캜esto se zanemaruje **kompleksnost** koju mikroservisi unose u razvoj. 캛ekaj, kakva kompleksnost!? Zar mikroservisi ne bi trebalo da upravo smanje slo쬰nost sistema time 코to ga dele na manje softverske komponente koje su jasno razdvojene?

Da. Misija mikroservisa je i da smanje uvezanost (_coupling_) izme캠u komponenata aplikacije. Svaki mikroservis ima svoje okru쬰nje, 쬴votni vek (_lifecycle_), procedure. Svaki servis se pojedina캜no mo쬰 optimizovati, skalirati po potrebi, nadograditi itd. bez da to ima uticaja na ostatak aplikacije; u pitanju je ne코to 코to nije lako ostvarivo u aplikaciji sa monolitnom arhitekturom.

Ipak, to je jedna strana medalje. Tamna strana je tamo gde kompleksnost uzvra캖a udarac i dovodi u pitanje projektne odluke. Poku코a캖u da sumiram pojedine bolne ta캜ke iz projekata 캜ija je arhitektura zasnovana na mikroservisima. Da budem potpuno fer, neki od ovih projekata su vrlo dinami캜ni, kada se ima u vidu broj razli캜itih komponenti sa kojima se barata u toku rada aplikacije. Ne zna캜i da 캖e i svaki drugi projekat da pati od istih nedostataka - ideja je da bar uka쬰m na stvari koje zahtevaju **vi코e pa쬹je** nego 코to bi se to o캜ekivalo.

## Razvoj

**Spremi se za izolaciju** - ne samo koda mikroservisa, ve캖 celog razvoja i procesa objavljivanja komponenti. To uklju캜uje (ali se ne ograni캜ava): razvoj koda, testova, priprema artefakta i, kona캜no, objavljivanje mikroservisa i njegovo ogla코avanje u eko-sistemu projekta. Sada je sve to potrebno uraditi za svaki mikroservis koji 캜ini aplikaciju. Ovo tra쬴 odre캠eni nivo kozistencije u procesima razvoja svih komponenti. Budi spreman da ulo쬴코 dodatno vreme, naro캜ito na po캜etku projekta, kada izolacija najverovatnije nije prva stvar o kojoj bi razmi코ljao. Ukoliko izolacija nije izvedena kako treba, projekat lako mo쬰 da se surva u omanji pakao razli캜itih verzija komponenata koje su 캜vrsto uvezane - ne캜ega 캜ega smo hteli da se re코imo u samom startu izborom mikroservisne arhitekture.

**Ne zaboravi s kim pri캜a코** - 캜esto se pozivi ka mikroservisima enkapsuliraju da bi sakrili transport, parsiranje rezultata, serijalizaciju argumenata, validaciju itd. Zbog ovoga kori코캖enje udaljenog (_remote_) API-ja postaje identi캜no pozivima lokalnih metoda. Vizuelno, na mestu kori코캖enja ne postoji nikakva razlika izme캠u poziva lokalne metode ili udaljenog servisa. I to je upravo mogu캖e mesto problema! Lako je zaboraviti 코ta se zapravo poziva. Mikroservisi po캜inju da se koriste kao da je lokalni kod: pozivaju se u petljama, u캜estvuju u sinhronizaciji, transakcijama... O캜igledno je da nije isto pozivati lokalni ili udaljeni servis! Poziv udaljenom servisu mo쬰 da ne uspe u bilo kom trenutku. Sporiji je, sa ka코njenjem na mestima na kojima se to ne o캜ekuje. Redosled izvr코avanja je nepredvidiv. Nema _rollback_ opcije kada nastane problem. Poziv udaljenom servisu mo쬰 캜ak da vrati i neispravne podatke. Zato svaki put kada se koristi udaljeni mikroservis, mora se biti svestan svi mogu캖ih problema koji mogu da nastanu. **Ne pretpostavi da poziv mikroservisa radi tek tako**. U stvari, teraj se da razmi코lja코 o tome 코ta 캖e se dogoditi ukoliko poziv ne uspe i probaj da na캠e코 re코enja za sve vrste gre코aka. Ako zbog svega ovoga kod po캜ne da ima previ코e "코uma", to nije razlog da se to ne radi, ve캖 je indikacija da bi kod trebalo bolje organizovati. Jednom tako, aplikacija na kojoj sam radio je upadala u nepredvi캠eno stanje po코to se je jedan od internih poziva me캠u mikroservisima jednostavno prekidao, i to u sredini izvr코avanja biznis logike. Nije postojao nikakav kod koji bi uhvatio gre코ku u transportu, kao ni kod da vrati stanje na prethodno u ovakvim slu캜ajevima. Po코to aplikacija nije znala da se oporavi od neispravnog stanja, prestala je da radi. U produkciji. Nakon drugog dana. Uh.

**Lokalni razvoj vi코e nije samo lokalni** - 캜est je slu캜aj da su programeru potrebne ostale komponente aplikacije tokom razvoja svog mikroservisa. To dodatno komplikuje stvari. Duboko sam ube캠en da programer mora da se fokusira samo na svoj zadatak i posao, a ne da gubi vreme na 쬺ngliranje sa infrastrukturom. Puno je ovde izazova koje treba re코iti: od startovanja minimalnog broja potrebnih komponenti infrastrukture u lokalu, pode코avanje DNS imena servisa, omogu캖avanje debagovanja i monitoringa, sve do izrade mockup-ova za pojedine mikroservise. Docker 캖e postati i najbolji prijatelj, ali i najve캖i neprijatelj u isto vreme. Spremi se da ulo쬴코 u alate za razvoj, izradu zajedni캜kih biblioteka, interne registre artefakta, ispravno verzionisanje... Sve da bi programeru pru쬴li slobodu da proizvodi kod bez previ코e zastoja (i smaranja). Sre캖an programer je dobar programer 游뗵

**Dokumentuj API i komuniciraj** - kao da ti 쬴vot zavisi od toga! Nau캜i kako se pravi, objavljuje i odr쬬va dobar API i interfejs. Promena API-ja zna da onesposobi druge kompomente; u svetu mikroservisa se to doga캠a u toku rada aplikacije, a ne tokom kompajliranja. Nemoj da 캜eka코 da integracioni test otkrije ove gre코ke. Na pravilan na캜in obave코tavaj tim o izmenama, naro캜ito one koji zavise od tvog mikroservisa. Objasni svoj API, najbolje kroz neki uobi캜ajeni format kao 코to je [Swagger](https://swagger.io/); dodaj primere kori코캖enja koji nisu banalni. Ne dozvoli da korisnik tvog API-ja naga캠a kako neki poziv radi. Ovo je va쬹o za bilo kakvu arhitekturu, no za mikroservise postaje jo코 va쬹ije. Odr쬬vaj i komuniciraj strukturu zavisnosti izme캠u komponenti, defini코i _upstream/downstream/compile-time/runtime_ zavisnost za svaki mikroservis.

**Integracioni testovi su obavezni**. Ono 코to bi bio unit test sa _mockup_-ovima u monolitnoj arhitekturi, u svetu mikroservisa je integracioni test. Moraju se testirati interakcije mikroservisa. Broj integracionih testova lako mo쬰 da eksplodira iznad nivoa upotrebljivosti, kada izvr코avanja testova traje neprakti캜no dugo, 캜ak i za relativno malu koli캜inu koda, 캜ine캖i CI bolno neupotrebljivim. Va쬹o je znati da ne treba sve da postane integracioni test. Razdvoji koncepte koji se mogu _mockup_-ovati od onih koji ba코 zahtevaju postojanje ostalih mikroservisa. Ovim se broj integracionih testova mo쬰 zna캜ajno smanjiti, a time i vreme testiranja. Ulo쬴 vreme u izradu dobrih _mockup_-ova. Treba te쬴ti da testovi 코to manje zavise od ostatka infrastrukture i ostalih mikroservisa.

**Stres** je dobar. 맚o ranije treba uklju캜iti testiranje aplikacije i infrastrukture na stres. Kada broj softverskih komponenti koje komuniciraju preko mre쬰 poraste, nema drugog na캜ina da se ustanovi kako se aplikacija pona코a. Rano stresiranje aplikacije jasno ukazuje na njene slabe ta캜ke. Koristi stres kao meru optimizacije i sredstvo za nala쬰nje granica sveukupnih performansi. Iskoristi stres da pogura코 aplikaciju "preko ivice" i proveri코 da li aplikacija zna da se oporavi nakon stresa i potom nastavi da radi.

**Nije sve mikroservis**. Mo쬰 biti veoma bolno i skupo ukoliko se softverska komponenta dizajnira kao mikroservis, a to u biti nije. Nau캜i razlike izme캠u **mikroservisa** i **modula** i **biblioteka**. Preispituj odluke; ukoliko neki modul, na pr., u캜estano poziva udaljeni servis koji pru쬬 va쬹u funkcionalnost aplikaciji, mogu캖e je da je on dobar kandidat da postane biblioteka. Mikroservise treba organizovati oko _biznis_ funkcionalnosti, a ne oko broj캜ano malog seta nekih funkcionalnosti. Ovo je konceptualna stvar i verovatno svaki programer druga캜ije razmi코lja na temu gde su granice mikroservisa; zato na samom po캜etku projekta treba formirati jasne definicije i prakse koje va쬰 za aplikaciju i komunikaciju izme캠u mikroservisa.

**Razvoj tra쬴 vi코e vremena**, o캜igledno. Koliko vi코e? Zavisi od kompleksnosti projekta, broja komponenti i volumena komunikacije me캠u njima; kao i od toga da li su ovde navedene napomene uzete u obzir. Dupliraj estimacije dok se ceo razvojni proces ne ustali.

## Infrastruktura

**Logovanje** se vi코e ne de코ava samo u konzoli. Logovanje je sada distribuiran proces koji obi캜no zahteva nekoliko zasebnih komponenata. Infrastruktura za logovanje mo쬰 da uklju캜i emitere logova, bafere, mesto za skladi코tenje (_datastore_) i komponente za vizualni prikaz i analizu logova. Razli캜iti mikroservisi loguju u razli캜itim formatima. Sve njih treba sakupiti na jednom mestu i podjednako ih obraditi. Tako캠e je bitna separacija logova po mikroservisu, ali i po jednoj instanci (kada je mikroservis skaliran). Saobra캖aj koji logovi stvaraju nije zanemarljiv, naro캜ito tokom _debug_-ovanja, 캜ak i za mali broj komponenti. Do쬴veo sam da je fajl sistem na [AWS](https://aws.amazon.com/) bacao `IO` _exception_ samo zato 코to nije uspevao da pravovremeno _flush_-uje sve logove u fajlove (u pitanju su bili male instance koje se nisu koristili u produkciji).

**Uklju캜i monitoring** od prvog dana. U stvari, nadgledaj aplikaciju od nultog dana! Jedina konstanta u arhtekturi sa mikroservisima je da bilo koja komponenta mo쬰 da prestane da radi u bilo kom trenutku. Do캖i do dobrog sistema za monitoring i detekciju gre코aka nije naivna stvar; kako god, treba ih uraditi 코to pre. Mora se imati informacija o tome kako se skup distribuiranih komponenti pona코a i da li ispravno radi. Monitoring bi trebalo da uklju캜i i _health check_ mikroservisa: provera ne samo da li je komponenta aktivna (na pr. da je neki port otvoren), ve캖 da li ona tako캠e radi kako treba. Nadgledanje treba da se bavi celom infrastrukturom sistema, a ne samo komponentama koje se razvijaju. Uklju캜i poruke upozorenja (_alert_) kada ne코to nije kako treba. Poku코aj da detektuje코 spore pozive, nagle IO promene, ka코njenja na mre쬴. Monitoring su o캜i uprte u sistem, otvori ih. Najgora stvar je da produkcija prestane da radi, a nema코 nikakvu ideju gde je gre코ka. Desilo mi se (pre)vi코e puta da dobijem samo SSH pristup na ra캜unar sa bukvalno hiljadama kontejenera i zadatak da otkrijem 코ta je krenulo kako ne treba. Mda, no캖 je ponekad veoma duga.

**Automatizcija je zakon** i bez nje nema smislenog projekta sa mikroservisima. Zbog broja softverskih i infrastrukturnih komponenti, nemogu캖e je razvijati bez ikakve automatizacije. Spremi sa na pisanje gomile _shell_ skriptova. Razli캜iti timovi mo쬯a imaju razli캜ite potrebe za automatizacijom i skriptovima. No automatizacija nisu samo skriptovi. Uklju캜ivanje CI/CD infrastrukture je tako캠e neophodan deo procesa razvoja, samo 코to sada mora da radi sa svim komponentama.

## Mikro zaklju캜ak

Gornje napomene se smatraju dobrim in쬰njerskim praksama, koje uvek va쬰 bez obzira na tip arhitekture. Ali stvar je u slede캖em: u monolitnoj aplikaciji, ne mora코 da ih ba코 sve implementira코. Neke se mogu uklju캜iti kasnije, ili u manjem obimu, ili da se 캜ak potpuno izostave. I mo쬰코 se izvu캖i s time.

Sa mikroservisima, ne sme se propustiti **ni jedna** od gornjih napomena. Nema jednostavnog na캜ina da se one zaobi캠u.

Sa mikroservisima, nije dovoljno biti samo dobar programer - potrebno je biti **vrhunski in쬰njer**. I ti i tvoj tim morate biti spremni na to.
